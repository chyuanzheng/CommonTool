/***********************************************************************/
/*                                                                     */
/*  FILE        :Createc.c                                             */
/*  DATE        :Fri, Nov 21, 2008                                     */
/*  DESCRIPTION :main program file.                                    */
/*  CPU GROUP   :2A                                                    */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.8).     */
/*  Producted by grt                                                   */
/*                                                                     */
/***********************************************************************/
/***********************************************************************/
/*                                                                     */
/*  System clock configuration                                         */
/*                                                                     */
/*  fxin ----> fcpu = 20M                                              */
/*       ----> f1,f2,f4,f8,f32=20M/32                                  */
/*  foco-s ----> foco = 125k                                           */
/*         ----> foco128 = 125k/128                                    */
/*                                                                     */
/***********************************************************************/

// Include files
#include "sfr_r82b.h"
#include "macro.h"
#include "key.h"
#include "iic.h" 
#include "memdef.h"
#include "timer.h" 


#define VER_YEAR	13
#define VER_MON		9
#define VER_DAY		18
#define VER_TIME	1
// Function prototype 
/* Initalize */	
void ConfigureFreq(void);
void PortConfigure(void);
void SfrInit(void);
void Initialize(void);
/* DSA */
void DSAInit(void); 
void WriteDSA(void);
void WriteDSAData(uint);
void WriteDSAPoint(void);
void ReadDSA(void);
unsigned char Read_Power_Chip_VDD12_Pin(void);
void  Power_Chip_Hold(void);
void check_power_normal(void) ;
/* IR */

/* delay */
extern void delay_us(uint us);
void delay_ms(uint ms);

/* keypad */
uchar CheckKey(uchar which);
uchar GetKeyValue(uchar which);
uchar CheckButton(uchar keyvalue);
/* radio */
void GetFSV();

/* watchdog */
void FeedDog();
void FeedDog1();
void wdt_init(void);

/* utile */
void i2cInit(void);
void ResetMCU(void);
void PulseMcu(void);
void PulseIR(void);
void ResetArm(void);

// Interrupt function prototype
#pragma INTERRUPT iic_irq
void iic_irq(void);
#pragma INTERRUPT key_irq
void key_irq(void);
#pragma INTERRUPT int1_irq
void int1_irq(void);
#pragma INTERRUPT ra_irq
void ra_irq(void);
#pragma INTERRUPT rb_irq
void rb_irq(void);
#pragma INTERRUPT rc_irq
void rc_irq(void);
//#pragma INTERRUPT int0_irq
//void int0_irq(void);


// Global variables
typedef struct _UINT32
{
	uint high;
	uint low;
} UINT32;
UINT32  TickCount = {0};
uint  IRCODE = 0;

uchar power_status;
#define POWERDOWN 		0
#define POWERWAITSLEEP 	1
#define POWERSLEEP 		2
#define POWERWAITDOWN	3
#define POWERERROR		4
#define POWERON	  		5
#define POWERCLICK 		6
#define POWERLONGPRESS	7

int powerdown_delay = 5000;

uchar ir_send_status = 0xfe;
int		ir_count_n = 0;
int     ir_count_p = 0;
uchar mcu_reset_flag =0 ;

#define PREEMBLE 0xff
#define IRIDLE	 0xfe


// for wheel key study
int WheelKeyLevel1 = 220;//255;
uchar WheelKeyFlag1 = 0;
int	WheelKeyTotal1 = 0;
int WheelKeyLevel2 = 220;//255;
uchar WheelKeyFlag2 = 0;
int WheelKeyTotal2 = 0;
int WheelTimes = 0;
int WheelTimes2 = 0;
int wait_acc_off_flag =0 ; 

volatile unsigned int power_chip_3681_hold_time =0 ;
volatile unsigned int check_power_chip_3681_time =0 ;

// up and down key
uchar DownKeyst = 0;

uchar subaddr = 0;
uchar subflag = 0;
uchar MemMap[256] = {0};	//for ce memory map


// for test funciton
uchar uErrorCode = 0;
uint  uTestTimes = 0;
void TestFun();

// for ir
uint IRADDRESS = 0xFF00;
uchar IrDevice = 0;
#define IRDTV	0
#define IRDVD	1		
uint custom_code = 0;
uint ir_code = 0;
uint ir_last_code = 0;
uchar IrUse = 0;
#define IDLE 0
#define SEND 1
#define RECV 2

// for keypad
const uchar KEY[] = {7,6,2,1,4};
uchar rotateKey1 = 0;
uchar rotateKey2 = 0;
uchar rotateKey3 = 0;
uchar rotateKey4 = 0;
uchar rotateStatus1 =0;
uchar rotateStatus2 =0;

#define KEYUP    0
#define KEYDOWN  1
#define KEYPRESS 2
#define KEYDONE  3

// for dvd

// for uint type
uchar unit_type = 0;

void delay_ms(uint ms)
{
	while(ms--)
	{
		delay_us(1000);
		FeedDog();
	}
	FeedDog();
}

void SendTVIRCode()
{
	IrDevice = IRDTV;
	IRADDRESS = MemMap[MEM_DTV_IR_CUSTOM] | ((uint)(~MemMap[MEM_DTV_IR_CUSTOM]))<<8;
	IRCODE = (MemMap[MEM_DTV_IR_CODE]) | ((uint)(~MemMap[MEM_DTV_IR_CODE]))<<8;
	MemMap[MEM_DTV_IR_CODE] = 0x0;
	// delay 9ms
	trbpre = 125-1;
	trbpr = 180 - 1;
	ir_send_status = PREEMBLE;
	DTV_IR = 0;
	tstart_trbcr = 1;
}

void SendDVDIRCode()
{

	if(MemMap[0x2f] == 0x5d)   // Powerdown dvd
	{
		if(MemMap[0x1d] == 0x55) // dvd is already power down
		{
			MemMap[0x2f] = 0xff;
			return;
		}
		if(MemMap[0x1d] == 0xff) // On first time, dvd hasnot power up
		{
			return;
		}
		if(IrUse == IDLE)
		{
			IrUse = SEND;
			IrDevice = IRDVD;
			IRADDRESS = 0xFF00;
			IRCODE = (MemMap[0x2f]) | ((uint)(~MemMap[0x2f]))<<8;
			MemMap[0x2f] = 0xff;
			// delay 9ms
			trbpre = 125-1;
			trbpr = 180 - 1;
			ir_send_status = PREEMBLE;
			tstart_trbcr = 1;	
			return;
			}
	}
	if(MemMap[0x2f] == 0x46)  // PowerUp dvd
	{
		if(MemMap[0x1d] != 0x55) // dvd is already power up;
		{
			MemMap[0x2f] = 0xff;
			return;
		}
		if(IrUse == IDLE)
		{
			IrUse = SEND;
			IrDevice = IRDVD;
			IRADDRESS = 0xFF00;
			IRCODE = (0x5d) | ((uint)(~0x5d))<<8;
			MemMap[0x2f] = 0xff;
			// delay 9ms
			trbpre = 125-1;
			trbpr = 180 - 1;
			ir_send_status = PREEMBLE;
			tstart_trbcr = 1;	
			return;
		}
	}	
}

void SendArmData(uchar id, uchar data)
{
	MemMap[MEM_CAR_STATE_CHANGE] = id;
	MemMap[id] = data;
	PulseMcu();
}

uint sub(UINT32 a, UINT32 b)
{
	if(a.high >= b.high)
	{
		if(a.high-b.high > 1)
		{
			return 0xFFFF;
		}
		if(a.high-b.high > 0)
		{
			if(a.low >= b.low)
			{
				return 0xFFFF;
			}
			else
			{
				return 0xFFFF - (b.low-a.low);
			}
		}
		if(a.high == b.high)
		{
			if(a.low > b.low)
			{
				return a.low - b.low;
			}
			else
			{
				return 0;
			}
		}
	}
	else
	{
		return 0;
	}
	return 0;
}

void CheckACC()
{
	int i;
	while(ACC == 1)
	{
	//	for(i=0;i<10000;i++)  //2013-07-10修改
	        for(i=0;i<2;i++)
		{
			//delay_us(100);
			delay_us(50); 
			if(POWERKEY)
			{
				i = 0;
			}
			VDD12_SW = 0;
			EXTAMP_SW = 0;
			DVD_SW = 0;
			DTV_SW = 0;
			TFT_SW = 0;
			DVD_SW = 0;
			FAN_SW = 0;
			if(ACC == 0)
			{
				break;
			}
		}
/*		if(ACC == 0)   //2013-07-10修改
		{
			break;
		}
		POWER_SW = 0;
		while(1)
		{
			VDD12_SW = 0;
			EXTAMP_SW = 0;
			DVD_SW = 0;
			DTV_SW = 0;
			TFT_SW = 0;
			DVD_SW = 0;
			FAN_SW = 0;
		}
*/		
		
	}	
	
	VDD12_SW = 1;
	TFT_SW = 1;
	DVD_SW = 1;
	FAN_SW = 1;
//	LED_SW = 1; 
}

void CheckPowerOffReason()
{
	int i=0;
	uchar iicdata = 0;
	i2cRead(0xa0,0,&iicdata);
	if(iicdata == 0xAA)
	{
	//	for(i=0;i<100;i++)
	//	{
		delay_us(5);
		if(POWERKEY == 1)
		{
		       
			return ;//break;
			
		}
	//	}
	//	if(i >= 100)
	//	{
			POWER_SW = 0;
			while(1)
			{
				asm("FCLR I");
				POWER_SW = 0;
			}
	//	}			
	}
	         		
}

void PowerKeyCheck()
{
	static UINT32 time1 = {0xFFFF,0xFFFF};
	static UINT32 time2 = {0};
	if(POWERKEY == 0)	// power key is up
	{
		if(power_status == POWERCLICK)
		{
			power_status = POWERON;
			SendArmData(MEM_POWER_KEY, 1);
		}
		else if(power_status == POWERLONGPRESS)
		{
			power_status = POWERON;
		} 
		else if(power_status == POWERWAITDOWN)
		{
					
			if(wait_timer(1))
			{
			   
					  	power_status = POWERDOWN;
				    	VDD12_SW = 0;
				   	    TFT_SW=0;
						POWER_SW = 0;
						while(1)
						{				       
							asm("FCLR I");
							POWER_SW = 0;
						}
		         	
			}
			else 
			{
					if(wait_acc_off_flag)
			       { 
					   	
					   if(ACC==0)
					   {
						    power_status = POWERDOWN;
							VDD12_SW = 0;
							TFT_SW=0;
						   mcu_reset_flag =1;		
					   }
	
				   } 
			}
				
		
		}
		else if(power_status == POWERDOWN)
		{
			POWER_SW = 0;
			while(1)
			{			    
				asm("FCLR I");
				POWER_SW = 0; 
			}
		}
		if(power_status == POWERON)
		{
			time1 = TickCount;
		}
	}
	if(POWERKEY)
	{
		// click
		time2 = TickCount;
		if(power_status >= POWERON)
		{
			
			if(sub(time2, time1) > 300 && sub(time2, time1)<=2500)//5000)	        
			{
				if (power_status != POWERLONGPRESS)
				{
					power_status = POWERLONGPRESS;
					SendArmData(MEM_POWER_KEY, 2);
				}	
			}
			else if(sub(time2,time1) >2500)//5000 )  //very long press powerkey. power off
			{
				if(power_status != POWERWAITDOWN)
				{
					power_status = POWERWAITDOWN;
					set_timer(1, 5000);
					SendArmData(MEM_SYSTEM_POWER_OFF, 1);
					AMPMUTE = 0;	
					// write powerdown reason
					i2cWrite(0xa0,0,0xAA);										
					delay_ms(100);				
					EXTAMP_SW = 0;
					DVD_SW = 0;
					FAN_SW = 0;
					LCD_SW = 1;
					
					
		
										
				}				
			}
			else 
			{
				power_status = POWERCLICK;
			}	
		}
		if(power_status == POWERWAITDOWN)
		{
			if(wait_timer(1))
			{
				VDD12_SW = 0;
				TFT_SW=0;					
			}	
		}		
	}	
}

void ACCCheck()
{
	static UINT32 acc_time1 = {0xFFFF,0xFFFF};
	UINT32 acc_time2 = {0};
	// if ACC is OFF, powerdown
	if(ACC)
	{
		if(power_status == POWERON)
		{
			acc_time1 = TickCount;
			power_status = POWERWAITSLEEP;		
		}
		if(power_status == POWERWAITSLEEP)
		{
			acc_time2 = TickCount;				
			if(sub(acc_time2,acc_time1) > 3000)
			{		
				power_status = POWERWAITDOWN;
				wait_acc_off_flag =1;
				set_timer(1, 5000);
				SendArmData(MEM_SYSTEM_POWER_OFF, 1);
				AMPMUTE = 0;	
				// write powerdown reason
				i2cWrite(0xa0,0,0x0);										
				delay_ms(100);				
				EXTAMP_SW = 0;
				DVD_SW = 0;
				FAN_SW = 0;
				LCD_SW = 1;			
			}
		}
	}
	else
	{
		// 
		if(power_status == POWERWAITSLEEP)
		{
			power_status = POWERON;
		}
	}	
}
 uchar carback = 255;
 uchar carlight = 255;
 uchar carbrake = 255;
void CarStatusCheck()
{

	if(BACK)
	{
		if(carback != 1)
		{
			carback = 1;
			SendArmData(MEM_BACK_STATUS, 0);
		}
	}
	else
	{
		if(carback != 0)
		{
			carback = 0;
			SendArmData(MEM_BACK_STATUS, 1);
		}
	}
	if(LIGHT)
	{
		if(carlight != 1)
		{
			carlight = 1;
			SendArmData(MEM_LIGHT_STATUS, 0);
		}
	}
	else
	{
		if(carlight != 0)
		{
			carlight = 0;
			SendArmData(MEM_LIGHT_STATUS, 1);
		}
	}
	if(BRAKE)
	{
		if(carbrake != 1)
		{
			carbrake = 1;
			SendArmData(MEM_BRAKE_STATUS, 0);
		}
	}
	else
	{
		if(carbrake != 0)
		{
			carbrake = 0;
			SendArmData(MEM_BRAKE_STATUS, 1);
		}
	}
}

void AD1KeyCheck()
{
	static uchar KeyStatus = KEYUP;
	static uchar key = 0;
	if(KeyStatus == KEYUP)
	{
		key = CheckKey(GetKeyValue(0));	// 
		if(key)
		{
			set_timer(2, 16);		// 
			KeyStatus = KEYDOWN;
		}
		else
		{
			KeyStatus = KEYUP;
		}
	}
	if(KeyStatus == KEYDOWN)
	{
		if(wait_timer(2))
		{
			if(key == CheckKey(GetKeyValue(0)))	// 
			{
				KeyStatus = KEYDONE;
				if(key == 2 || key == 3) // volume+/-
				{
					KeyStatus = KEYPRESS;
					set_timer(3, 200);
				}
			}
			else
			{
				KeyStatus = KEYUP;
			}
			if(KeyStatus == KEYDONE || KeyStatus == KEYPRESS)
			{
				SendArmData(key, 1);
			}
		}
	}
	if(KeyStatus == KEYDONE)
	{
		key = CheckKey(GetKeyValue(0));
		if(key == 0)
		{
			KeyStatus = KEYUP;
		}
	}
	if(KeyStatus == KEYPRESS)
	{
		if(key == CheckKey(GetKeyValue(0)))	// 
		{
			if(wait_timer(3))
			{
				SendArmData(key, 1);
				set_timer(3, 80);
			}
		}
		else
		{
			kill_timer(3);
			KeyStatus = KEYUP;
		}	
	}
}

void AD2KeyCheck()
{
	static uchar KeyStatus = KEYUP;
	static uchar key = 0;
	if(KeyStatus == KEYUP)
	{
		key = CheckKey(GetKeyValue(1));	// AD按键2
		if(key)
		{
			set_timer(4, 16);		// 延时
			KeyStatus = KEYDOWN;
		}
		else
		{
			KeyStatus = KEYUP;
		}
	}
	if(KeyStatus == KEYDOWN)
	{
		if(wait_timer(4))
		{
			if(key == CheckKey(GetKeyValue(1)))	// AD按键2
			{
				KeyStatus = KEYDONE;
			}
			else
			{
				KeyStatus = KEYUP;
			}
			if(KeyStatus == KEYDONE)
			{
				SendArmData(key+10, 1);
			}
		}
	}
	if(KeyStatus == KEYDONE)
	{
		key = CheckKey(GetKeyValue(1));
		if(key == 0)
		{
			KeyStatus = KEYUP;
		}
	}
	if(KeyStatus == KEYPRESS)
	{
		if(key == CheckKey(GetKeyValue(1)))	// AD按键2
		{
			if(wait_timer(5))
			{
				SendArmData(key+10, 1);
				set_timer(5, 80);
			}
		}
		else
		{
			kill_timer(5);
			KeyStatus = KEYUP;
		}	
	}
}

void Wheel1KeyCheck()
{
	static uchar KeyStatus = KEYUP;
	static uchar key = 0;
	static uchar key1 = 0;
	if(KeyStatus == KEYUP)
	{
		key = GetKeyValue(2);
		if(key <( WheelKeyLevel1-10))
		{
			set_timer(6, 32);		// 延时	/* 方向盘按键需要更长的延时 */
			key = GetKeyValue(2);
			KeyStatus = KEYDOWN;
		}
		else
		{
			KeyStatus = KEYUP;
		}
	}
	if(KeyStatus == KEYDOWN)
	{
		if(wait_timer(5))
 //     delay_us(20);
		{
			key1 = GetKeyValue(2);
			if(key1 < WheelKeyLevel1)
			{
				if(key1-key < 10 || key-key1 < 10)
				{
					// some key pressed
					SendArmData(MEM_WHEEL_KEY, key/2);
					KeyStatus = KEYDONE;
				}
				else
				{
//						KeyStatus = KEYUP;
				}		
			}
			else
			{
				KeyStatus = KEYUP;
			}
		}
	}
	if(KeyStatus == KEYDONE)
	{
		key = GetKeyValue(2);
		if(key >=(WheelKeyLevel1-8))
		{
			KeyStatus = KEYUP;
			SendArmData(MEM_WHEEL_KEY, 255);
		}
	}
}

void Wheel2KeyCheck()
{
	static uchar KeyStatus = KEYUP;
	static uchar key = 0;
	static uchar key1 = 0;
	if(KeyStatus == KEYUP)
	{
		key = GetKeyValue(3);
		if(key < (WheelKeyLevel2-10))
		{
			set_timer(6, 32);		// 延时	/* 方向盘按键需要更长的延时 */
			key = GetKeyValue(3);
			KeyStatus = KEYDOWN;
		}
		else
		{
			KeyStatus = KEYUP;
		}
	}
	if(KeyStatus == KEYDOWN)
	{
		if(wait_timer(5))
 //     delay_us(20);
		{
			key1 = GetKeyValue(3);
			if(key1 < WheelKeyLevel2)
			{
				if(key1-key < 10 || key-key1 < 10)
				{
					// some key pressed
					SendArmData(MEM_WHEEL_KEY, (key/2+128));
					KeyStatus = KEYDONE;
				}
				else
				{
//						KeyStatus = KEYUP;
				}		
			}
			else
			{
				KeyStatus = KEYUP;
			}
		}
	}
	if(KeyStatus == KEYDONE)
	{
		key = GetKeyValue(3);
		if(key >=(WheelKeyLevel2-8))
		{
			KeyStatus = KEYUP;
			SendArmData(MEM_WHEEL_KEY, 255);
		}
	}
}

void HandlerIRCode()
{
	// handle ir command
	if(IrUse == 0 && ir_code)
	{
		SendArmData(MEM_IR_ARM, KeyMap[(uchar)ir_code]);
		ir_code = 0;
	}
	if((MemMap[MEM_DTV_IR_CODE] != 0x0) && (ir_send_status == IRIDLE) && IrUse == 0)
	{
		IrUse = SEND;
		SendTVIRCode();
	}
}

void HandlerArmCMD(uchar code, uchar data)
{
	if(code == MEM_FAN_POWER)
	{
		FAN_SW = data;
	}
	if(code == MEM_TFT_POWER)
	{
		TFT_SW = data;
	}
	if(code == MEM_EXTAMP_POWER)
	{
		EXTAMP_SW = data;
	}
	if(code == MEM_DVD_POWER)
	{
		DVD_SW = data;
	}
	if(code == MEM_VDD12_POWER)
	{
		VDD12_SW = data;
	}
	if(code == MEM_DTV_POWER)
	{
		DTV_SW = data;
	}
	if(code == MEM_NJW_OUTPUT)
	{
		switch(data)
		{
			case 0:
			NJW_OUTPUT1;
			break;
			case 1:
			NJW_OUTPUT2;
			break;
			case 2:
			NJW_OUTPUT3;
			break;
		}
	}
	if(code == MEM_SYSTEM_POWER_OFF)
	{
		kill_timer(1);
		power_chip_3681_hold_time = 0xff00;
	}
}


void InitMemMap()
{
	int i=0;
	for(i=0;i<256;i++)
	{
		MemMap[i] = 0;
	}
	MemMap[MEM_MCU_VER_YEAR] = VER_YEAR;			// version.y
	MemMap[MEM_MCU_VER_MONTH] = VER_MON | (VER_TIME<<4);         	// version.m
	MemMap[MEM_MCU_VER_DAY] = VER_DAY;			// version.d 
}

void main(void)
{	
	int key = 0;
	int key1 = 0;
	int value =0 ;
	
	// Initialize system

 	Initialize();
	// lock power pin
 	POWER_SW = 1;

start:	
      carback = 255;
      carlight = 255;
      carbrake = 255;
	check_power_normal();  
	CheckACC();

        TickCount.high = 0;
	TickCount.low = 0;      
	AMPMUTE = 0;
	AMPSTBY = 0;

	// Interrupt enable
	asm("FSET I");	
	
	I2CInit();
	
	CheckPowerOffReason();
	
	delay_us(10);
	delay_ms(50);
	InitMemMap();
	// open 12v and ce power
		
	power_status = POWERON;
//	if(mcu_reset_flag)
	        ResetArm();
	LED_SW = 1; 
	DTV_IR = 1;
	LCD_SW = 0;
	
	AMPSTBY = 1;
	WheelKeyLevel2 =GetKeyValue(3);
	WheelKeyLevel1 =GetKeyValue(2);
	wdt_init();
	
	power_status = POWERON;
	INT_MCU = 1;
	// main loop
		mcu_reset_flag =0 ;
	while(1) 
	{
		FeedDog();
		PowerKeyCheck();
		ACCCheck();
	
		if(power_status >= POWERON)
		{
			CarStatusCheck();
			AD1KeyCheck();
			AD2KeyCheck();
			Wheel1KeyCheck();			
			Wheel2KeyCheck();
			HandlerIRCode();
		}
		FAN_SW = 1;
	
		Power_Chip_Hold();
		if(mcu_reset_flag)
		{
		
		
	         
			    goto start;
		}		
	}
	//POWER_SW = 0;
}
void Initialize(void)
{
	pd6_2 = 1;
	p6_2 = 1;	
	ConfigureFreq();
	PortConfigure();
	SfrInit();
}
void ConfigureFreq(void)
{
	/* Interrupt disable 							*/
	asm("FCLR I");
	/* Protect off 									*/
	prcr = 1;
	/* Xin Xout 									*/
	cm13 = 1;
	/* XCIN-XCOUT drive capacity select bit : HIGH 	*/
	cm15 = 1;
	/* Xin on 										*/
	cm05 = 0;
	/* Main clock = No division mode 				*/
	cm16 = 0;
	/* Main clock = No division mode 				*/
	cm17 = 0;
	/* CM16 and CM17 enable 						*/
	cm06 = 0;
	/* Waitting for stable of oscillation 			*/
	asm("nop");
	asm("nop");
	asm("nop");
	asm("nop");
	/* Main clock change 							*/
	ocd2 = 0;
	/* Protect on 									*/
	prcr = 0;
}

void PortConfigure(void)
{
	// P0.0-P0.3 for ad convert               P0.2 CE/TV switch
	// P0.4-P0.7 for ad convert, AN3-AN0
	prc2 = 1;
	pd0 = 0b10010100;
	prc2 = 0;
	p0 = 0b00000000;
	// P1.0-P1.3 for keypad input,default = input (or key interrupt)
	// P1.4-P1.6 for power swicth,default = output low;P1.7 for IR,default = input 
	pd1 = 0b01110000;
	p1 = 0x00;
	// P2.0-P2.7 for DVD function
	// P2.0 DVD_CLK          output high
	// P2.1 DVD_STB			 output high
	// P2.2 DVD_DATA		 output high
	// P2.3 DVD_TRAY_IN		 input	
	// P2.4 DVD_TRAY_OUT	 input
	// P2.5 DVD_DISC_OK		 input
	// P2.6 DVD_DISC_OUT	 output low
	// P2.7 DVD_DISC_IN		 output low
	pd2 = 0b11100111;
	p2  = 0b00000111;
      
	// P3.0-P3.1 for motor contol, default = output low
	// P3.2-P3.3 for motor position detect, default = input
	// P3.4-P3.5 for iic
	// P3.6 for beep and aux/ipod select on siwtch, default = output low, beep = 1 for wince startup
	// P3.7 Power status detect, default = input
//	pd3 = 0b01001111;
    pd3 = 0b11001111;    
	p3 =  0b00000000;
	// P4.5 rds ready detect, input
//	pd4 = 0b00011000;
    pd4 = 0b00111000;
	p4 =  0b00100000;
	
	// P5.0,P5.2-P5.4 for power switch, default = output low, beep sw = high ,,, p5_4 rds ready
	// P5.3 for Power key, default = input
	// P5.1 for motor count, default = timer C input
	// P5.0 for beep output low
	// P5.5-P5.7 not use, default = output low
	pd5 = 0b11100101;
	p5 = 0x01;
        
	// P6.0-P6.2 for AMP mute,AMP standby and output power switch, default = 0b100
	// P6.3 for IPOD detect, default = input
	// P6.4-P6.5 for DVD ir control and DVD reset, default= output high
	// P6.6 for 
	// P6.7 for iic master
	pd6 = 0b11111111;
//	p6  = 0b11111000; 
   	p6  = 0b11110100; 

	// P8.0-P8.2 for interrupt to ce2440 and DTV ir, P8.0-P8.1 default = input low P8.2 default = output high
	// P8.3-P8.6 for car status detect, default = input
	// P8.7 not use, default = output low
	pd8 = 0b10000111;
	p8  = 0b00000000;
}

void i2cInit(void)
{
	
	int i;
	asm("FCLR I");
	/* for iic */
	// disable i2c interrupt, level = 5
	//iicic = 0x0;
	// I2C bus wait
	//mstiic = 0;
	// select I2C bus function
	//iicsel = 0;
	// clear stop flag
	//stop_icsr = 0;
	// enable transform
	//ice_iccr1 = 0;
	// set clock(f1/200) slave mode
	//iccr1 = 0x0;
	// initialize
	//iccr2 = 0x0;
	// no wait, send MSB first
	//icmr = 0x00;
	// ...
	//icier = 0x0;
	// initialize
	//icsr = 0x00;
	// set slave address,0xD2
	//sar = 0x0;
	
	// P3_5,P3_4 input mode
	pd3 &= 0xCF;
	// I2C bus wait
	mstiic = 1;
	// select I2C bus function
	iicsel = 1;
	// clear stop flag
	stop_icsr = 0;
	// enable transform
	ice_iccr1 = 1;
	// set clock(f1/200) slave mode
	iccr1 = 0x8D;
	// initialize
	iccr2 = 0xF0;
	// no wait, send MSB first
	icmr = 0x00;
	// ...
	icier = 0xA4;
	// initialize
	icsr = 0x00;
	// set slave address,0xD2
	sar = 0xD2;
	// enable i2c interrupt, level = 5
	iicic = 0x4;
	asm("FSET I");
}

#define FEQFACT	4
void SfrInit(void)
{
	/* for iic */
	// P3_5,P3_4 input mode
	pd3 &= 0xCF;
	// I2C bus wait
	mstiic = 1;
	// select I2C bus function
	iicsel = 1;
	// clear stop flag
	stop_icsr = 0;
	// enable transform
	ice_iccr1 = 1;
	// set clock(f1/200) slave mode
	iccr1 = 0x8D;
	// initialize
	iccr2 = 0xF0;
	// no wait, send MSB first
	icmr = 0x00;
	// ...
	icier = 0xA4;
	// initialize
	icsr = 0x00;
	// set slave address,0xD2
	sar = 0xD2;
	// enable i2c interrupt, level = 5
	iicic = 0x4;
	
	/* for timercounter A */
	// set timer io
	traioc = 0x00;	// timer mode, all disable
	// select timer source and timercounter mode
	tramr = 0b00110000; // source supplied, f2 = 10M, timer mode
	// enable ra int
	traic = 0x7;
	//genarate interrupt per 1/4ms
	trapre = 100 -1;
	tra = 100/FEQFACT - 1;    /* 修改成1/4ms 100318*/
	tundf_tracr = 0;
	tstart_tracr = 1;
	/* for timercounter B */
	// for IR send
	trbmr = 0b00010000;	// source supplied, f8 = 1.25M, timer mode
	trbioc = 0x00;
	trbic = 0x6;
	
	/* for timercounter C */
	msttrc = 1;	
	trcmr = 0b00001000;	// timer mode
	trccr1 = 0;	// source = f1
	trcier = 1; // disable overflow interrupt, enable trcIOA interrupt
	trcdf = 0b11000001; // enable digit filter for trcIOA
	trcior0 = 0b10001110;	//trcIOA both-edge trigger
	trcic = 0x3;


#if 1	
	// select P1.7
	int1sel = 0;
	/* for extern INT, used by IR */
	int1en = 1;
	int1pl = 0; // single edge trigger
	// f32 filter
	int1f0 = 1;
	int1f1 = 1;
	// select falling edge trigger
	pol_int1ic = 0;
	int1ic = 6;
	
#endif

	/* for ad converter */
	adcon1 = 0b00100000;	// Vcut connect Vref, 8 bit mode, ad freq = f4
	adcon2 = 0b00000001; // ad port = P0
}

void delay_ra(uchar prescale, uchar scale)
{
	trapre = prescale;
	tra = scale;
	tundf_tracr = 0;
	tstart_tracr = 1;
	while(tundf_tracr==0);
	tundf_tracr = 0;
	tstart_tracr = 0;		
}

// timer A interrupt, per 1ms for system clock
void ra_irq(void)
{
	static uchar fact = 0;
	tundf_tracr = 0;
        
	if(fact++ == FEQFACT)
	{
	        if(power_chip_3681_hold_time++ >= 0xfff0)
			{
				power_chip_3681_hold_time = 0xfff0;
			}
            if(check_power_chip_3681_time ++ >=0xfff0)
			{
			    check_power_chip_3681_time =0xfff0;
			}
		fact = 0;
		TickCount.low++;
		if(TickCount.low == 0)
		{
			TickCount.high++;
		}
		handler_timer();
	}	
}

uchar flag = 0;
void iic_irq(void)
{
	unsigned char dummy,data;
	unsigned char address;	
	uint time = 0;
	if(aas_icsr == 1)  // slave address matched
	{
		// clear stop flag
		stop_icsr = 0;
		// dummy read icddr, read the slvaddr
		dummy = icdrr;
		address = dummy & 0x1;
		if(address == 0x1) // master read me
		{
			// clear slvaddr matched flag
			aas_icsr = 0;	
			icdrt = MemMap[subaddr];
			// wait transmit buffer empty
			while(tdre_icsr==0)
			{
				if(time++>5000)
				{
					time = 0;
					icsr = 0;
					goto ERROR;
				}
			}

			// wait transmit completed
			while(tend_icsr==0)
			{
				if(time++>5000)
				{
					time = 0;
					goto ERROR;
				}
			}

			// clear transmit complete flag
			tend_icsr = 0;
			// clear NACK detect bit
			nackf_icsr = 0;
			// recv flag
			iccr1 &= 0xEF;
			// ..
			dummy = icdrr;
			// ...
			tdre_icsr = 0;
			while(stop_icsr==0)
			{
				if(time++>5000)
				{
					time = 0;
					goto ERROR;
				}
			}

			stop_icsr = 0;
			flag = 0;
			return;
		}
		else	// master write me 
		{
			// clear slvaddr matched flag
			aas_icsr = 0;
			// send ack
    		ackbt_icier = 0;
			// dummy read,release bus
			dummy = icdrr;
			if(aas_icsr == 1)
				aas_icsr = 0;
			// waite recv buffer full,to read subaddr
			while(rdrf_icsr==0)
			{
				if(time++>5000)
				{
					time = 0;
					goto ERROR;
				}
			}
			subaddr = icdrr;
			flag = 1;
			return;
			
		}
	}

	else // no slaveaddr matched
	{
//		if(rdrf_icsr == 1)
		{
			flag = 0;
			ackbt_icier = 0;
			// dummy..
			//dummy = icdrr;

			// waite recv buffer full,to read subaddr
			if(aas_icsr == 1)
				aas_icsr = 0;
			while(rdrf_icsr==0)
			{
				if(rdrf_icsr==1)
					dummy = icdrr;
				if(time++>5000)
				{
					time = 0;
					goto ERROR;
				}
			}

			// read the data
			//while(rdrf_icsr==1)
			MemMap[subaddr] = icdrr;
			HandlerArmCMD(subaddr, MemMap[subaddr]);			
			if(aas_icsr == 1)
				aas_icsr = 0;
			// wait stop bit valid
			while(stop_icsr==0)
			{
				if(time++>10000)
				{
					time = 0;
					goto ERROR;
				}
			}

			// clear stop bit
			stop_icsr = 0;
			return;
		}
	}
ERROR:
	iicrst_iccr2 = 1;	
	i2cInit();
	iicrst_iccr2 = 0;
}

void key_irq(void)
{
	// eject key
}
void int1_irq(void)
{
	//uint customer_code;
	if(IrUse == IDLE)
	{
		int1ic = 0;	// disable int1 
		IrUse = RECV;
		// delay 4.5ms
		trbpre = 125-1;
		trbpr = 90 - 1;
		ir_send_status = PREEMBLE;
		tstart_trbcr = 1;
	}
}


// for ir send/receive

/* IR 还不支持连续键接收*/

uchar ir_level = 1;

void rb_irq(void)
{
	char ir_high = 0;
	char ir_low = 0;
	tstop_trbcr = 1;
	// receive
	if(IrUse == RECV)
	{
#if 0
		if(ir_send_status == PREEMBLE)
		{
			if(IR_IN == 1)
			{
				ir_send_status = IRIDLE;
				int1ic = 0x6;
				IrUse = IDLE;
				return;
			}
			else
			{
				// delay 10.4 = 9+0.28+0.56*2ms
				trbpre = 125-1;
				trbpr = 204-1;
				ir_send_status++;
				tstart_trbcr = 1;
				return;
			}
		}
		if(ir_send_status < 16)
		{
			if(IR_IN == 0)
			{
				custom_code >>= 1;
				// delay 1.125ms
				trbpre = 50-1;
				trbpr = 56-1;
				ir_send_status++;
				tstart_trbcr = 1;
			}
			else
			{
				custom_code >>= 1;
				custom_code |= 0x8000;
				// delay 2,25ms
				trbpre = 50-1;
				trbpr = 112-1;
				ir_send_status++;
				tstart_trbcr = 1;
			}
		}
		else if(ir_send_status < 32)
		{
			if(IR_IN == 0)
			{
				ir_code >>= 1;
				// delay 1.125ms
				trbpre = 50-1;
				trbpr = 56-1;
				ir_send_status++;
				tstart_trbcr = 1;
			}
			else
			{
				ir_code >>= 1;
				ir_code |= 0x8000;
				// delay 2.25ms
				trbpre = 50-1;
				trbpr = 112-1;
				ir_send_status++;
				tstart_trbcr = 1;
			}
		}
		else if(ir_send_status == 32)
		{
			ir_send_status = IRIDLE;
			if(custom_code == 0xff00)
			{
				Beep();
			}
			else
			{
				{
					custom_code = ir_code = 0;
				}
			}
			int1ic = 0x6;
			IrUse = IDLE;
		}
		return;
#else
		if(ir_send_status == PREEMBLE)
		{
			if(IR_IN == 1)
			{
				ir_send_status = IRIDLE;
				int1ic = 0x6;
				IrUse = IDLE;
				return;
			}
			else
			{
				// delay 7ms
				trbpre = 125-1;
				trbpr = 140-1;
				ir_send_status++;
				tstart_trbcr = 1;
				ir_count_n = 0;
				ir_count_p = 0;
				return;
			}
		}
		if(ir_send_status < 16)
		{
			if(IR_IN == 0)
			{
				ir_count_n++;
				/* 第一次进入,如果是低电平说明是重复码 */
				if(ir_count_p == 0 && ir_send_status == 0)
				{
					ir_send_status = IRIDLE;
					int1ic = 0x6;
					IrUse = IDLE;
					if((ir_last_code & 0xFF) == 0x48 || (ir_last_code & 0xFF) == 0x40)
					{
						ir_code = ir_last_code;
					}
					return;
				}
				
				if(ir_count_p > 1)
				{
					/* 此时已经采集完一个高电平,判断码值 */
					if(ir_count_p > 15 && ir_count_p < 70)
					{
						// bit 0
						custom_code >>= 1;
					}
					else if(ir_count_p > 70 && ir_count_p < 120)
					{
						// bit 1
						custom_code >>= 1;
						custom_code |= 0x8000;
					}
					else
					{
						ir_count_p = 0;
					}
					ir_send_status++;
					ir_count_n = 0;
					ir_count_p = 0;				
				}
			}
			else
			{
				/* 第一次进入,如果是高电平,说明是引导码 */
				if(ir_count_n == 0 && ir_send_status == 0)
				{
					/* 跳过引导码 */
					ir_count_p = 1;
					trbpre = 5-1;
					trbpr = 5-1;
					tstart_trbcr = 1;				
				}
				else
				{
					ir_count_p++;
					if(ir_count_p > 200) 
					{
						ir_count_n = 0;
						ir_count_p = 0;
						ir_send_status++;
					}				
				}
			}
						// delay 10us
			trbpre = 5-1;
			trbpr = 5-1;
			tstart_trbcr = 1;
		}
		else if(ir_send_status < 32)
		{
			if(IR_IN == 0)
			{
				ir_count_n++;
				if(ir_count_p)
				{
					/* 此时已经采集完一个高电平,判断码值 */
					if(ir_count_p > 15 && ir_count_p < 70)
					{
						// bit 0
						ir_code >>= 1;
					}
					else if(ir_count_p > 70 && ir_count_p < 120)
					{
						// bit 1
						ir_code >>= 1;
						ir_code |= 0x8000;
					}
					else
					{
						ir_count_p = 0;
					}
					ir_send_status++;
					ir_count_n = 0;
					ir_count_p = 0;				
				}				
			}
			else
			{
				ir_count_p++;
				if(ir_count_p > 200)
				{
					ir_count_n = 0;
					ir_count_p = 0;
					ir_send_status++;
				}
			}
						// delay 10us
			trbpre = 5-1;
			trbpr = 5-1;
			tstart_trbcr = 1;
		}
		else if(ir_send_status == 32)
		{
			ir_send_status = IRIDLE;
			ir_high = ir_code >> 8;
			ir_low = ir_code;
			if(custom_code == 0xff00 && (ir_high) == ~(ir_low))
			{
				ir_last_code = ir_code;
			}
			else
			{
				{
					custom_code = ir_code = 0;
					ir_last_code = 0;
				}
			}
			int1ic = 0x6;
			IrUse = IDLE;
		}
		return;
#endif
	}

	// send
	if(IrUse == SEND)
	{
		if(ir_send_status == PREEMBLE)
		{
			trbpre = 125-1;
			trbpr = 90-1;
			if(IrDevice == IRDTV)
			{
				DTV_IR = 1;
			}
			if(IrDevice == IRDVD)
			{
				DVD_IR = 1;
			}
			ir_send_status++;
			tstart_trbcr = 1;
			return;
		}
	if(ir_send_status < 16)
	{
		if(IRADDRESS>>(ir_send_status) & 0x1) // send 1
		{
			if(ir_level == 1)
			{
				trbpre = 50 - 1;
				trbpr = 28 - 1;
				if(IrDevice == IRDTV)
				{
					DTV_IR = 0;
				}
				if(IrDevice == IRDVD)
				{
					DVD_IR = 0;
				}			
				ir_level = 0;
				tstart_trbcr = 1;
			}
			else if(ir_level == 0)
			{
				trbpre = 50 - 1;
				trbpr = 84 - 1;
				if(IrDevice == IRDTV)
				{
					DTV_IR = 1;
				}
				if(IrDevice == IRDVD)
				{
					DVD_IR = 1;
				}
				ir_level = 1;
				ir_send_status++;
				tstart_trbcr = 1;
			}
		}
		else // send 1
		{
			if(ir_level == 1)
			{
				trbpre = 50 - 1;
				trbpr = 28 - 1;
				if(IrDevice == IRDTV)
				{
					DTV_IR = 0;
				}
				if(IrDevice == IRDVD)
				{
					DVD_IR = 0;
				}
				ir_level = 0;
				tstart_trbcr = 1;
			}
			else if(ir_level == 0)
			{
				trbpre = 50 - 1;
				trbpr = 28 - 1;
				if(IrDevice == IRDTV)
				{
					DTV_IR = 1;
				}
				if(IrDevice == IRDVD)
				{
					DVD_IR = 1;
				}
				ir_level = 1;
				ir_send_status++;
				tstart_trbcr = 1;
			}
		}
	}
	else if(ir_send_status < 32)
	{
		if((IRCODE>>(ir_send_status-16))  & 0x1 ) // send 1
		{
			if(ir_level == 1)
			{
				trbpre = 50 - 1;
				trbpr = 28 - 1;
				if(IrDevice == IRDTV)
				{
					DTV_IR = 0;
				}
				if(IrDevice == IRDVD)
				{
					DVD_IR = 0;
				}
				ir_level = 0;
				tstart_trbcr = 1;
			}
			else if(ir_level == 0)
			{
				trbpre = 50 - 1;																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																					
				trbpr = 84 - 1;
				if(IrDevice == IRDTV)
				{
					DTV_IR = 1;
				}
				if(IrDevice == IRDVD)
				{
					DVD_IR = 1;
				}
				ir_level = 1;
				ir_send_status++;
				tstart_trbcr = 1;
			}
		}
		else // send 1
		{
			if(ir_level == 1)
			{
				trbpre = 50 - 1;
				trbpr = 28 - 1;
				if(IrDevice == IRDTV)
				{
					DTV_IR = 0;
				}
				if(IrDevice == IRDVD)
				{
					DVD_IR = 0;
				}
				ir_level = 0;
				tstart_trbcr = 1;
			}
			else if(ir_level == 0)
			{
				trbpre = 50 - 1;
				trbpr = 28 - 1;
				if(IrDevice == IRDTV)
				{
					DTV_IR = 1;
				}
				if(IrDevice == IRDVD)
				{
					DVD_IR = 1;
				}
				ir_level = 1;
				ir_send_status++;
				tstart_trbcr = 1;
			}
		}
	}
	else if(ir_send_status++ == 32)
	{
		trbpre = 50 - 1;
		trbpr = 28 - 1;
		if(IrDevice == IRDTV)
		{
			DTV_IR = 0;
		}
		if(IrDevice == IRDVD)
		{
			DVD_IR = 0;
		}
		tstart_trbcr = 1;
	}
	else
	{
		if(IrDevice == IRDTV)
		{
			DTV_IR = 1;
		}
		if(IrDevice == IRDVD)
		{
			DVD_IR = 1;
		}		
		ir_send_status = IRIDLE;
		IrUse = IDLE;
	}
	}

}

// for motor counter
void rc_irq(void)
{
	imfa_trcsr = 0;
}

void GetFSV()
{
	if(BACK == 0)
	{
		if(MemMap[4] == 0x82)
		{
			MemMap[9] = 30;
			MemMap[4] = 0x55;
			PulseMcu();
		}
	}
	else
	{
		if(MemMap[4] == 0x55)
		{
			MemMap[9] = 30;
			MemMap[4] = 0x82;
			PulseMcu();
		}
	}
}

uchar GetKeyValue(uchar which)
{
	uchar adret = 0xFF;
	uchar i=0;
	int k =0;
	unsigned int buffer =0 ;
	adcon0 = KEY[which];
	for(i=0;i<50;i++)
	{
		delay_us(10);
		FeedDog();
		adst = 1;
		while((adst == 1)&&(k<2000))
		{
		        k++;
		        FeedDog();
		}        
		        
		             
	    buffer+=ad0; 
//		if(ad0 < adret)
//		{
//			adret = ad0;
//		}
 	}
//	return adret;
    return(buffer/50);
}
uchar CheckKey(uchar keyvalue)
{
	int i=0;
	for(i=0;i<sizeof(KeyValue)/sizeof(KeyValue[0]);i++)
	{
		if(keyvalue<=KeyValue[i]+8 && keyvalue>=KeyValue[i]-8)  
		{
			return i;
		}
	}
	return 0;
}

uchar CheckButton(uchar keyvalue)
{
	int i=0;
	int key = 255;
	for(i=0;i<sizeof(ButtValue)/sizeof(ButtValue[0]);i++)
	{
		if(keyvalue<=ButtValue[i]+8 && keyvalue>=ButtValue[i]-8)  
		{
			key = i;
			break;
		}
	}
	switch(key)
	{
		case 0:
		{
			return KEY_PANEL;
		}
		case 1:
		{
			return KEY_HOME;
		}
		case 2:
		{
			return KEY_MODE;
		}
		case 3:
		{
			return KEY_RETRUN;
		}
		case 4:
		{
			return KEY_VOLU;
		}
		case 5:
		{
			return KEY_VOLD;
		}
		case 6:
		{
			return KEY_OPEN;
		}
	}
	return 0;
}

/*
void int0_irq(void)
{
	int i=0;
	MemMap[9] = 30;
	INT_IR = 0;
	for(i=0;i<200;i++)
	{
		asm("NOP");
	}
	INT_IR = 1;
}
*/
void FeedDog()
{
	asm("FCLR I");
	wdtr = 0x00;
	wdtr = 0xff;	
	asm("FSET I");	
}

void FeedDog1()
{
	wdtr = 0x00;
	wdtr = 0xff;	
}

void wdt_init(void)
{
	/* switch BCLK to f8 so we have a longer timeout period */

	/* unprotect Clock mode register0 so we can modify clock */
	prcr = 3;

	/* Watchdog function after it times out:0 -(default) generate interrupt, 1 - resets the MCU */
	pm12 = 1;
	/* 0 (default) - jumps to the watchdog interrupt routine */
	/* 1 - resets the MCU */

	/* protect PM1 */
	prcr = 0;

	/* prescaler is div by 128 watchdog timer period = (32,768 x 128) / (2.5MHz) = 1.677s */
	 wdc7 = 1;



	/* Start Watchdog Timer by writing any value to wdts register (value
	always resets to 0x7fff when written to) */
	wdtr = 0x00;
	wdtr = 0xFF;
	wdts = 0xff;
}

void PulseMcu(void)
{
	/*
	@20101106
	修改原因见开发日志 20101106 条
	*/
	int i;
	pd8_0 = 1;
	INT_MCU = 0;
	for(i=0;i<200;i++)
	{
		asm("NOP");
	}
	//pd8_0 = 0;
	INT_MCU = 1;
}

void ResetArm(void)
{
	//VDD12_SW = 0;
	//delay_ms(200);
	//VDD12_SW = 1;
	//delay_ms(300);
	delay_ms(500);
	pd5_0 = 1;
	p5_0 = 0;
	delay_ms(500);
	p5_0 = 1;	
	delay_ms(200);
}





unsigned char Read_Power_Chip_VDD12_Pin(void) 
{
        unsigned int  ad_buffer =0 ;
        ad_buffer =GetKeyValue(4);
        if(ad_buffer>=196)           //16V 过压
                return (1);
        else if((ad_buffer<196)&&(ad_buffer>=195)) 
              return (4);         
	else if((ad_buffer<195)&&(ad_buffer>=110))//9.5v-15.5V正常工作电压
		return (2) ;
	else if(ad_buffer<=103)	     //9.0V
                return (0) ; 
	else
              return (3);
             	
}

void check_power_normal(void)
{
	check_power_chip_3681_time=0;
	 while((Read_Power_Chip_VDD12_Pin()==1)||(Read_Power_Chip_VDD12_Pin()==4))
	{
	         FeedDog();
                	                        
	         if(check_power_chip_3681_time>=15000)  //15S power off 
	     	   		POWER_SW = 0;	 
					
	    
	}	
	while((Read_Power_Chip_VDD12_Pin()!=2))
	{
			FeedDog();  
	
	}
}

 void  Power_Chip_Hold(void)
 {
	unsigned char  power_undervoltage_status = 0 ,power_overvoltage_flag=0,power_undervoltage_flag=0;
	 unsigned char power_chip_unusual_flag =0;
	 
	   power_chip_3681_hold_time=0 ; 
	   check_power_chip_3681_time =0 ;     
         while(Read_Power_Chip_VDD12_Pin()==1) //过压
         	 {
	                 FeedDog();
	                   
                 	 if((power_chip_3681_hold_time>=1000)&&(power_chip_unusual_flag==0)) //过压
                        {
                  		    power_chip_unusual_flag =1;
						  	power_chip_3681_hold_time =0 ;
				      		SendArmData(MEM_SYSTEM_POWER_OFF, 1);
							EXTAMP_SW = 0;  //功放控制线先关闭，否则会出现功放的POPO声
							AMPMUTE = 0;	
							// write powerdown reason
							i2cWrite(0xa0,0,0x0);										
							delay_ms(100);
							while(power_chip_3681_hold_time<5000)
						  	{
						       	FeedDog();
						  	}  				
							
							DVD_SW = 0;
							FAN_SW = 0;
							LCD_SW = 1;
							VDD12_SW = 0;
							TFT_SW = 0;
							
						     
		                  		   mcu_reset_flag =1 ; 
                  	
                  	}
                  	   
         	        
         	 }
          while (Read_Power_Chip_VDD12_Pin()==0)//欠压
         	 {
         	       FeedDog(); 
         	        if(GetKeyValue(4) < 71)
					{
						// reset arm
						ResetArm();
					}
         	        if((check_power_chip_3681_time>=5000)&&(power_undervoltage_status==0)) //欠压
         	        {
         	                power_undervoltage_status =1 ;
          		
						power_chip_3681_hold_time =0 ;
				      		SendArmData(MEM_SYSTEM_POWER_OFF, 1);
							EXTAMP_SW = 0;
							AMPMUTE = 0;	
							// write powerdown reason
							i2cWrite(0xa0,0,0x0);										
							delay_ms(100);
							while(power_chip_3681_hold_time<5000)
						  	{
						       	FeedDog();
						  	}  				
							
							DVD_SW = 0;
							FAN_SW = 0;
							LCD_SW = 1;
							VDD12_SW = 0;
							TFT_SW = 0;
						     
				
         	        }
         	        power_undervoltage_flag =1 ;
         	 }             	
         	
            
                 	
        if((power_undervoltage_flag)&&(check_power_chip_3681_time<=5000))	
        {
		
					power_undervoltage_flag =0 ;
		//	LCD_ON();
			
	 	}
		else if((power_undervoltage_flag)&&(check_power_chip_3681_time>5000))	
		{
					mcu_reset_flag =1 ;	
		
					power_undervoltage_flag =0 ;
	
		}

		           	
 }
 
 
 void PulseIR(void)
{
	/*
	将IR改为RDSReady,所以注释掉PulseIR,见日志20101110
	*/
/*		
	int i;
	pd8_1 = 1;
	INT_IR = 0;
	for(i=0;i<200;i++)
	{
		asm("NOP");
	}
	pd8_1 = 0; 
	INT_IR = 1;
*/
}

void TestFun()
{
	/*
	errorcode 
	0 : 无错误 
	1 : 无碟
	2 : 进碟错误
	3 : 碟状态错误
	4 : 上滑屏错误
	5 : 下滑屏错误
	6 : 出碟错误\
	7 : 未定义
	8 : 用户退出
	*/
}